#!/opt/perl/bin/perl

use 5.026;

use strict;
use warnings;
no  warnings 'syntax';

use experimental 'signatures';

@ARGV = "input" unless @ARGV;

my @instructions;

my %expected_registers = (
    snd => 1,
    set => 2,
    add => 2,
    mul => 2,
    mod => 2,
    rcv => 1,
    jgz => 2,
);

while (<>) {
    chomp;
    my ($command, @registers) = split;
    if (@registers == $expected_registers {$command}) {
        push @instructions => [$command => @registers];
    }
    else {
        die "Failed to parse $_";
    }
}

my $STATUS_RUNNING = 0;
my $STATUS_WAITING = 1;
my $STATUS_DONE    = 2;

package Tablet {
    use Hash::Util::FieldHash qw [fieldhash];

    fieldhash my %registers;
    fieldhash my %pc;
    fieldhash my %status;

    sub new  ($class) {bless do {\my $var} => $class}
    sub init ($self, %args) {
        $registers {$self} = {map {$_ => 0} 'a' .. 'z'};
        $pc        {$self} = 0;
        $status    {$self} = $STATUS_RUNNING;
        $self;
    }

    #
    # Return a value. If the input is the name of a register,
    # we return the value in the register, else we just return
    # the input.
    #
    sub value ($self, $name_or_value) {
        $registers {$self} {$name_or_value} // $name_or_value;
    }

    #
    # set, add, multiply or take the modulus
    #
    sub set ($self, $name, $val) {
        $registers {$self} {$name}  = $self -> value ($val);
    }

    sub add ($self, $name, $val) {
        $registers {$self} {$name} += $self -> value ($val);
    }

    sub mul ($self, $name, $val) {
        $registers {$self} {$name} *= $self -> value ($val);
    }

    sub mod ($self, $name, $val) {
        $registers {$self} {$name} %= $self -> value ($val);
    }

    #
    # Jump an offset. Note that the program counter already has
    # incremented, so we have to subtract one.
    #
    sub jgz ($self, $cond, $offset) {
        if ($self -> value ($cond) > 0) {
            $pc {$self} += $self -> value ($offset) - 1;
        }
    }

    #
    # Return the current status
    #
    sub status ($self) {
        $status {$self};
    }

    #
    # Perform a single instruction. Set status to done if 
    # the program counter gets below 0, or goes outside
    # of the set of instructions.
    #
    sub tick ($self) {
        return unless $self -> status == $STATUS_RUNNING;

        my ($command, @args) = @{$instructions [$pc {$self} ++]};
        $self -> $command (@args);
        $status {$self} = $STATUS_DONE if $pc {$self} < 0 ||
                                          $pc {$self} >= @instructions;
    }

    #
    # The different parts of the puzzle treat the 'snd'
    # and 'rcv' actions differently, so set up different
    # classes from each part, inheriting from the main class.
    #
    # Calling each of the methods in the parent class will
    # be a fatal error.
    #
    sub snd ($self, $freq) {...;}
    sub rcv ($self, $rec)  {...;}

    #
    # Quick and dirty subclasses, which go out and reach into their
    # parents data parts. Yuck.
    #
    package Tablet::Part1 {
        use Hash::Util::FieldHash qw [fieldhash];
        our @ISA = qw [Tablet];

        fieldhash my %last_sound;  # Remember the last sound played.

        #
        # Play sound
        #
        sub snd ($self, $freq) {
            $last_sound {$self} = $self -> value ($freq);
        }

        #
        # Optionally recover a sound played. If we do,
        # that's the end of the program.
        #
        sub rcv ($self, $rec) {
            if ($self -> value ($rec)) {
                $status {$self} = $STATUS_DONE;
            }
        }

        #
        # Retrieve the last sound played
        #
        sub last_sound ($self) {
            $last_sound {$self};
        }
    }

    package Tablet::Part2 {
        use Hash::Util::FieldHash qw [fieldhash];
        our @ISA = qw [Tablet];

        fieldhash my %send_to;     # Which tablet do we send to?
        fieldhash my %queue;       # Queue with values received.
        fieldhash my %times_send;  # Keep track of many times we send.

        #
        # Initialize our stuff, then let the parent class do its thing
        #
        sub init ($self, %args) {
            $send_to {$self}       = delete $args {send_to};
            my $id                 = delete $args {id};
            $queue   {$self}       = [];
            $self -> SUPER::init (%args);
            $registers {$self} {p} = $id;
        }

        #
        # Receive a value: put it in the queue, and if we're
        # in a waiting status, switch back to a running status
        #
        sub received ($self, $value) {
            push @{$queue {$self}} => $value;
            $status {$self} = $STATUS_RUNNING
                  if $status {$self} == $STATUS_WAITING;
        }

        #
        # Send a value to another tablet.
        #
        sub snd ($self, $val) {
            $send_to    {$self} -> received ($self -> value ($val));
            $times_send {$self} ++;
        }

        #
        # Receive an item from the queue, and store it in
        # a register. If the queue is empty, start waiting.
        #
        sub rcv ($self, $reg) {
            if (@{$queue {$self}}) {
                $registers {$self} {$reg} = shift @{$queue {$self}};
            }
            else {
                #
                # Wait. *Decrement* the pc, so the next time
                # around, we'll try again
                #
                $pc {$self} --;
                $status {$self} = $STATUS_WAITING;
            }
        }

        #
        # Return how often we send something.
        #
        sub times_send ($self) {
            $times_send {$self};
        }
    }
}


#
# Part 1
#

{
    my $tablet = Tablet::Part1:: -> new -> init;
    while ($tablet -> status != $STATUS_DONE) {
           $tablet -> tick;
    }
    say "Solution 1: ", $tablet -> last_sound;
}


#
# Part 2
#
{
    my $tablet_0 = Tablet::Part2:: -> new;
    my $tablet_1 = Tablet::Part2:: -> new;
    $tablet_0 -> init (send_to => $tablet_1, id => 0);
    $tablet_1 -> init (send_to => $tablet_0, id => 1);

    #
    # We keep going as long as at least one table is in the running status.
    #
    {
        $tablet_0 -> tick while $tablet_0 -> status == $STATUS_RUNNING;
        $tablet_1 -> tick while $tablet_1 -> status == $STATUS_RUNNING;

        # Only need to check tablet_0 here.
        redo if $tablet_0 -> status == $STATUS_RUNNING;
    }

    say "Solution 2: ", $tablet_1 -> times_send;
}
           



__END__
